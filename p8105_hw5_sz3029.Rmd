---
title: "P8105 HW5"
author: Shihui Zhu sz3029
output: github_document
---

```{r setup, include=FALSE}
# Reproducibility
set.seed(1)

# This chunk loads all the packages used in this homework
library(tidyverse)
library(viridis)
library(ggridges)
library(patchwork)

library(readxl)

# General figure set up
knitr::opts_chunk$set(
  # display the code in github doc
  echo = TRUE,
  # hide warning messages
  warning = FALSE,
  message = FALSE,
  # set the figure to be 8 x 6, and the proportion it takes to be 95%
  fig.width = 10,
  fig.height = 8, 
  out.width = "90%"
)

# setting a global options for continuous data color family and a different format to set discrete data to have a color family
options(
  ggplot2.countinuous.colour = "viridis",
  ggplot2.countinuous.fill = "viridis"
)

scale_colour_discrete = scale_colour_viridis_d
scale_fill_discrete = scale_fill_viridis_d

# have a minimal theme and legends at the bottom
theme_set(theme_minimal() + theme(legend.position = "bottom"))
```

## Problem 1

### Describe the raw data
```{r p1_1, message=FALSE}
homicides <- 
  read_csv("data/homicide-data.csv", na = c("", "Unkown")) %>%
  # create a citystate variable
  mutate(
    city_state = str_c(city, state),
    resolution = case_when(
      disposition == "Closed without arrest" ~ "unsolved",
      disposition == "Open/No arrest"        ~ "unsolved",
      disposition == "Closed by arrest"     ~ "solved"
      )
    ) %>%
  relocate(city_state) %>%
  # exclude the wrong issue
  filter(city_state != "TulsaAL")
```

There is a data-entry issue for the city Tulsa. This needs to be fixed in the raw dataset so we just ignore it for now. 

Summarize within cities to obtain the total number of homicides and the number of unsolved homicides
```{r}
homicides %>%
  group_by(city_state) %>%
  summarise(
    unsolved = sum(resolution == "unsolved"),
    total = n()
  ) #%>%
  #mutate(
    #test_results = map2(unsolved, n, prop.test),
    #tidy_results = map(test_results, broom::tidy)
  #) %>%
  #select(city_state, tidy_results) %>%
  #unnest(tidy_results) %>%
  #select(city_state, estimate, starts_with("conf"))
```


### Let's focus on Baltimore, MD.

```{r}
baltimore_df <-
  homicides %>%
  filter(city_state == "BaltimoreMD")

baltimore_summary <-
  baltimore_df %>%
    summarize(
      unsolved = sum(resolution == "unsolved"),
      n = n()
    )

baltimore_test <-
  prop.test(
    x = baltimore_summary %>% pull(unsolved),
    n = baltimore_summary %>% pull(n)
  )

# organize the test output as dataframe
baltimore_test %>%
  broom::tidy()
```

### Let's try to iterate across cities!

First off, write a function and test on sample cities.

```{r}
prop_test_function = function(city_df) {
  
  city_summary <-
    city_df %>%
      summarize(
        unsolved = sum(resolution == "unsolved"),
        n = n()
    )

  city_test <-
    prop.test(
      x = city_summary %>% pull(unsolved),
      n = city_summary %>% pull(n)
    )
  
  return(city_test)
}

prop_test_function(baltimore_df)

homicides %>%
  filter(city_state == "AlbuquerqueNM") %>%
  prop_test_function()
```

### Now, let's iterate across all cities

```{r}
results_df <- 
  homicides %>%
  nest(data = uid:resolution) %>%
  mutate(
    test_results = map(data, prop_test_function),
    tidy_results = map(test_results, broom::tidy)
  ) %>%
  select(city_state, tidy_results) %>%
  unnest(tidy_results) %>%
  select(city_state, estimate, starts_with("conf"))
```

### Try to make a plot showing estimates and confidence intervals.

```{r}
results_df %>%
  mutate(city_state = fct_reorder(city_state, estimate)) %>%
  ggplot(aes(x = city_state, y = estimate)) +
  geom_point() +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```

## Problem 2

Start with a dataframe containing all file names via the `list.files`
```{r zip_data}
zip_list <-
  tibble(
    files = list.files("data/zip_data/")
  )
```

Iterate over file names and read in data for each subject using `purrr::map` and saving the result as a new variable in the dataframe

```{r map}
zip_df <-
  zip_list %>%
  mutate(
    files = str_c("data/zip_data/", files)
  ) %>%
  mutate(
    data = map(files, ~read_csv(.))
  )
```

Tidy the result
```{r}
zip_tidy <-
  zip_df %>%
  mutate(
    files = str_replace(files, "data/zip_data/", ""),
    files = str_replace(files, ".csv", "")
  ) %>%
  unnest(data) %>%
  separate(files, c("arm", "id"), "_") %>%
  mutate(
    arm = ifelse(arm == "con", "control", "experimental")
  ) %>%
  pivot_longer(
    week_1:week_8,
    names_to = "week",
    names_prefix = "week_",
    values_to = "observations"
  ) %>%
  mutate(
    id = as.factor(as.numeric(id)),
    week = as.numeric(week)
  )
zip_tidy
```

Make a spaghetti plot showing observations on each subject over time
```{r}
zip_tidy %>%
  mutate(
    arm_id = str_c(arm, "_", id)
  ) %>%
  ggplot(aes(x = week, y = observations, color = arm_id)) + 
  geom_line(aes(linetype = arm)) +
  labs(
    title = "Spaghetti Plot for observations on each subject over time",
    x = "Week",
    y = "Observations on each subjects",
    caption = "Data from zip files"
  ) + 
  scale_colour_hue()
```

From the spaghetti plot we observe that both arms have similar range of observations at the start of week 1, but the experimental group ends up with higher observation values compared with the control group at the end of the study i.e. at week 8.

## Problem 3

### Fill in missing values for `iris` dataset

```{r}
set.seed(10)

iris_with_missing = iris %>% 
  map_df(~replace(.x, sample(1:150, 20), NA)) %>%
  mutate(Species = as.character(Species))
```

Write a function for missing values.

```{r missing_func}
fill_in_missing = function(vector) {
  # fill in missing values with the mean of non-missing values
  if (is.numeric(vector)) {
    vector = replace_na(vector, mean(vector, na.rm = TRUE))
  }
  # fill in missing values with "virginica"
  if (is.character(vector)) {
    vector = replace_na(vector, "virginica")
  }
  
  return(vector)
}
```

Apply the function column by column

```{r fill_na}
iris_with_missing <-
  iris_with_missing %>%
  map(fill_in_missing)

bind_rows(iris_with_missing)
```

